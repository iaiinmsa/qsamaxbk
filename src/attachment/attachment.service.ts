import { Injectable, NotFoundException, InternalServerErrorException } from '@nestjs/common';
import { PrismaService } from '../prisma/prisma.service';
import { NonConformityAttachment } from '@prisma/client';
import * as fs from 'fs/promises';
import * as path from 'path';

@Injectable()
export class AttachmentService {
  constructor(private prisma: PrismaService) {}

  async createAttachment(
    file: Express.Multer.File,
  ): Promise<NonConformityAttachment> {
    if (!file) {
      throw new InternalServerErrorException('File not provided for attachment.');
    }
    // The filePath should be relative to a public/static serving directory or a URL if stored in cloud
    // For local storage, ensure the 'uploads/attachments' directory exists
    const filePath = `uploads/attachments/${file.filename}`; // filename is generated by multer

    try {
      const attachment = await this.prisma.nonConformityAttachment.create({
        data: {
          filePath: filePath,
          fileName: file.filename, // file.originalname,
          loadDate: new Date(),
        },
      });
      return attachment;
    } catch (error) {
      // If DB operation fails, try to clean up the uploaded file
      try {
        await fs.unlink(path.join(process.cwd(), 'public', filePath)); // Adjust if your public root is different
      } catch (cleanupError) {
        console.error('Failed to cleanup uploaded file after DB error:', cleanupError);
      }
      throw new InternalServerErrorException(
        `Could not save attachment to database: ${error.message}`,
      );
    }
  }

  async findAllAttachments(): Promise<NonConformityAttachment[]> {
    return this.prisma.nonConformityAttachment.findMany();
  }


  async findOneAttachment(id: number): Promise<NonConformityAttachment> { // Cambiado de NonConformityAttachment | null
    const attachment = await this.prisma.nonConformityAttachment.findUnique({
      where: { nonConformityAttachmentId: id },
    });
    if (!attachment) {
      throw new NotFoundException(`Attachment with ID ${id} not found`);
    }
    return attachment; // TypeScript ahora sabe que esto siempre es NonConformityAttachment si no se lanza una excepci√≥n
  }

  async removeAttachment(id: number): Promise<NonConformityAttachment> {
    const attachment = await this.findOneAttachment(id); // Checks if exists and throws NotFoundException

    if (attachment.filePath) {
      try {
        // Construct the full path to the file on the server
        // This assumes files are stored in a 'public' directory at the project root
        // Adjust this path according to your file storage strategy
        const fullFilePath = path.join(process.cwd(), 'public', attachment.filePath);
        await fs.unlink(fullFilePath);
      } catch (error) {
        // Log error but proceed to delete DB record, or handle more gracefully
        console.error(`Failed to delete file ${attachment.filePath} from disk: ${error.message}`);
        // Depending on policy, you might choose to not delete the DB record if file deletion fails
      }
    }

    return this.prisma.nonConformityAttachment.delete({
      where: { nonConformityAttachmentId: id },
    });
  }
}